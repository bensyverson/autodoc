#!/usr/bin/env node

/*
 * I apologize in advance to anyone reading this file.
 * It is a mess. Needs some serious refactoring.
 * My primary goal right now is to focus on making it just work,
 * specifically for Lazy.js (http://danieltao.com/lazy.js/).
 * Once that's done I will do my best to circle back and clean this up!
 */

var fs           = require('fs'),
    path         = require('path'),
    Breakneck    = require(path.join(__dirname, '../breakneck-node')),
    stringTable  = require('string-table'),
    commander    = require('commander'),
    Mustache     = require('mustache'),
    Lazy         = require('lazy.js');

require('colors');
require('should');

var packagePath = path.join(__dirname, '../package.json'),
    packageInfo = JSON.parse(fs.readFileSync(packagePath));

function argToList(arg) {
  return arg.split(/,\s*/);
}

commander
  .version(packageInfo.version)
  .usage('[options] [file]')

  // TODO: Implement these eventually
  // .option('-t, --test', 'run tests')
  // .option('-p, --perf', 'run performance benchmarks')

  .option('-v, --variable <name>', 'provide a name for the variable traditionally used by the library (e.g., jQuery, $, _) -- used for tests and benchmarks')
  .option('-o, --output <destination>', 'specify an output directory (defaults to "docs")')
  .option('-n, --namespaces <names>', 'provide a comma-separated list of the namespaces to document (defaults to all, in alphabetical order)', argToList)
  .option('-j, --javascripts <sources>', 'specify additional JS dependencies (comma-separated)', argToList)
  .option('--tagged <tag>', 'only use the methods tagged with the specified tag')
  .parse(process.argv);

if (process.argv.length <= 2) {
  commander.help();
  process.exit();
}

var filePath     = Lazy(process.argv).last(),
    outputDir    = commander.output || 'docs',
    javascripts  = commander.javascripts || [],
    helperPath   = path.join(outputDir, 'doc_helper.js'),
    helperExists = fs.existsSync(helperPath),
    configPath   = path.join(outputDir, 'handlers.js'),
    configExists = fs.existsSync(configPath),
    libraryInfo  = Breakneck.parse(fs.readFileSync(filePath, 'utf-8'));

var docsToInlude = Lazy(libraryInfo.docs);

if (commander.tagged) {
  docsToInlude = docsToInlude.filter(function(doc) {
    return Lazy(doc.tags).contains(commander.tagged);
  });
}

var groupedByNamespace = docsToInlude
  .groupBy(function(doc) {
    return doc.namespace || doc.shortName;
  })
  .toObject();

// Only include specified namespaces, if the option has been provided.
var namespaces = Lazy(commander.namespaces || Object.keys(groupedByNamespace))
  .map(function(namespace) {
    // Find the corresponding constructor, if one exists.
    var constructorMethod = Lazy(libraryInfo.docs)
                              .findWhere({ name: namespace }),

        members           = Lazy(groupedByNamespace[namespace])
                              .reject(function(doc) {
                                return doc.name === namespace;
                              })
                              .sortBy(function(doc) {
                                // Talk about hacky...
                                // This is how I've decided to put static methods first.
                                return (doc.isStatic ? 'a' : 'b') + doc.shortName;
                              })
                              .toArray();

    var allMembers = Lazy([constructorMethod]).concat(members)
      .compact()
      .toArray();

    // Decorate constructors w/ the correct CSS class
    // (it's easier to do here than in the template).
    Lazy(allMembers).each(function(member) {
      member.sectionType = member.isConstructor ? 'constructor' : 'method';
    });

    return {
      namespace: namespace,
      constructorMethod: constructorMethod,
      members: members,

      // This is so that in the main <article> in the docs, methods are displayed
      // in the same order as in the navigation area.
      allMembers: allMembers
    };
  })
  .toArray();

var templateData = Lazy(libraryInfo)
  .extend({
    javascripts: javascripts,
    namespaces: namespaces
  })
  .toObject();

if (helperExists) {
  templateData.javascripts.push('doc_helper.js');
}

var config = { handlers: [] };

// Allow a library to provide a config.js file, which should define a handlers
// array like:
//
// [
//   { pattern: /regex/, matcher: function(match, actual) },
//   { pattern: /regex/, matcher: function(match, actual) },
//   ...
// ]
//
if (configExists) {
  // First of all, include it in the actual docs HTML.
  templateData.javascripts.push('handlers.js');

  // Also require it locally.
  config = require(path.join(process.cwd(), configPath));

  // Then, look at all of our examples...
  // those that are matched by some handler, we will leave to be handled
  // in some custom way.
  Lazy(templateData.docs)
    .map(function(doc) {
      return doc.examples.examples;
    })
    .flatten()
    .each(function(example) {
      Lazy(config.exampleHandlers || []).each(function(handler, i) {
        if (handler.pattern.test(example.output)) {
          // Mark this example as being handled
          example.customHandler = true;
          example.handlerIndex = i;

          // Force output to look like a string
          example.outputPattern = JSON.stringify(example.output);

          // Exit early
          return false;
        }
      });
    });
}

var template = fs.readFileSync(path.join(__dirname, '../resources/docs.html.mustache'), 'utf-8'),
    docsHtml = Mustache.render(template, templateData);

function copyFile(source, destination, force) {
  // Don't obliterate files that are already there.
  // TODO: Think about this a bit more.
  if (force || !fs.existsSync(destination)) {
    fs.createReadStream(source).pipe(fs.createWriteStream(destination));
  }
}

if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir);
}

fs.writeFileSync(path.join(outputDir, 'index.html'), docsHtml);
copyFile(path.join(__dirname, '../resources/docs.css'), path.join(outputDir, 'docs.css'));
copyFile(path.join(__dirname, '../resources/gears.gif'), path.join(outputDir, 'gears.gif'));
copyFile(path.join(__dirname, '../resources/utils.js'), path.join(outputDir, 'utils.js'));
copyFile(path.join(__dirname, '../resources/docs.js'), path.join(outputDir, 'docs.js'));

console.log('Docs written to ' + outputDir + '/');
